# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

### Flutter Environment
This project uses FVM (Flutter Version Management) with Flutter 3.35.4. Always prefix Flutter commands with `fvm`:

- `fvm flutter pub get` - Install dependencies
- `fvm flutter pub deps` - Show dependency tree
- `fvm flutter clean && fvm flutter pub get` - Clean and reinstall dependencies

### Code Generation
The project uses build_runner for code generation (injectable, freezed, json_serializable, mockito):
- `fvm flutter packages pub run build_runner build` - Generate all code (DI, models, mocks)
- `fvm flutter packages pub run build_runner build --delete-conflicting-outputs` - Force regenerate

**Important**: Generated files (*.g.dart, *.freezed.dart, *.mocks.dart, *.config.dart) are NOT committed to Git. After cloning the repository, you MUST run code generation before building or running the app.

### Running the App
Multi-flavor setup using dart-define-from-file:
- `fvm flutter run --flavor dev --dart-define-from-file=dart_defines/dev.json` - Development
- `fvm flutter run --flavor stg --dart-define-from-file=dart_defines/stg.json` - Staging
- `fvm flutter run --flavor prod --dart-define-from-file=dart_defines/prod.json` - Production

### Building
- `fvm flutter build apk --flavor dev --dart-define-from-file=dart_defines/dev.json` - Development APK
- `fvm flutter build apk --flavor stg --dart-define-from-file=dart_defines/stg.json` - Staging APK
- `fvm flutter build apk --flavor prod --dart-define-from-file=dart_defines/prod.json` - Production APK
- `fvm flutter build ios --flavor prod --dart-define-from-file=dart_defines/prod.json` - Production iOS build

### Analysis and Testing
- `fvm flutter analyze` - Static analysis (required before commits)
- `fvm flutter test` - Run unit tests
- `fvm flutter test test/specific_test.dart` - Run a single test file
- `dart format .` - Format code

## Architecture

### Clean Architecture with Feature-First Structure
The codebase follows Clean Architecture principles organized by features:

```
lib/
├── features/                    # Feature modules (feature-first organization)
│   └── user/                    # Example: User feature
│       ├── domain/              # Business logic layer
│       │   ├── entities/        # Core business objects (User)
│       │   ├── repositories/    # Abstract repository interfaces
│       │   └── usecase/         # Business use cases
│       ├── data/                # Data layer
│       │   ├── datasource/      # Remote/local data sources
│       │   ├── models/          # Data transfer objects with toEntity() methods
│       │   └── repositories/    # Repository implementations
│       └── presentation/        # UI layer
│           └── pages/           # Feature-specific pages
└── core/                        # Shared/cross-cutting concerns
    ├── config/                  # App configuration (flavors, environment)
    ├── network/                 # HTTP client, interceptors, error handling
    │   ├── dio_client.dart      # Dio HTTP client setup with proxy support
    │   ├── interceptors/        # Auth and other interceptors
    │   ├── error/               # Error handling utilities
    │   └── mock/                # Mock API setup for development
    ├── injection/               # Dependency injection configuration
    ├── widgets/                 # Shared widgets
    └── constants/               # App-wide constants
```

### Dependency Injection
Uses `get_it` with `injectable` for dependency injection:
- `core/injection/injection.dart` - Main DI configuration with `configureDependencies()` function
- `core/injection/injection.config.dart` - Generated DI registration (auto-generated by build_runner)
- All services registered with `@Injectable()` annotations
- Repositories injected as interfaces using `@Injectable(as: Interface)`
- DioClient registered as `@preResolve` with `@lazySingleton` scope for async initialization

### Multi-Flavor Configuration
- `core/config/app_config.dart` - Contains Flavor enum and all configuration logic
- `dart_defines/` - JSON configuration files for each flavor:
  - `dev.json` - Development environment (flavor: "dev")
  - `stg.json` - Staging environment (flavor: "stg")
  - `prod.json` - Production environment (flavor: "prod")
- `AppConfig.fromEnvironment()` - Factory constructor that reads flavor from dart-define
- `AppConfig.currentFlavor` - Current flavor accessor
- `AppConfig.isProduction` - Production environment check
- `AppConfig.flavorTitle` - Human-readable flavor title for UI
- `AppConfig.mockApiDataSource` - Boolean flag to enable mock API responses
- `AppConfig.isNeedProxy` - Boolean flag to enable proxy configuration
- All dart-define fields use snake_case naming: `app_name`, `base_url`, `mock_api_data_source`, `is_need_proxy`
- Supports both full names (develop/staging/production) and short forms (dev/stg/prod)

### HTTP Client Setup
Located in `core/network/dio_client.dart`:
- Dio HTTP client with environment-specific base URLs from AppConfig
- Mock API adapter using `http_mock_adapter` when `mockApiDataSource` is true
- System proxy detection and configuration via `native_flutter_proxy`
- Auth interceptor for request authentication (`core/network/interceptors/auth_interceptor.dart`)
- Debug logging in development mode using Dio's LogInterceptor
- Proxy bypass for non-production environments
- Certificate validation handling for staging/dev environments

### Mock API Setup
Located in `core/network/mock/`:
- `mock_setup.dart` - Configures DioAdapter with mock responses
- `mock_responses.dart` - Defines mock response data
- Activated when `AppConfig.mockApiDataSource` is true (enabled in dev flavor)
- Useful for development without backend dependencies

### Key Dependencies
- `dio` - HTTP client
- `flutter_bloc` - State management
- `get_it` + `injectable` - Dependency injection
- `shared_preferences` - Local storage
- `flutter_inappwebview` - WebView integration
- `freezed` + `freezed_annotation` - Immutable data classes with code generation
- `json_serializable` + `json_annotation` - JSON serialization/deserialization
- `mockito` - Mocking for unit tests
- `build_runner` - Code generation orchestrator
- `http_mock_adapter` - Mock HTTP responses for development
- `native_flutter_proxy` - System proxy detection

## Important Notes

- Always run `fvm flutter analyze` before committing changes
- The project follows feature-first organization - keep feature code within its module
- Respect Clean Architecture layer boundaries: domain → data → presentation
- Use the existing DI container (`getIt`) rather than creating manual dependencies
- Follow the established naming conventions: UpperCamelCase for types, lowerCamelCase for members
- Flavor-specific resources are organized in platform folders (android/ios have flavor subdirectories)
- When adding new features, follow the existing feature module structure under `lib/features/`
- Data models should always have a `toEntity()` method to convert to domain entities
- The global `appConfig` variable in `main.dart` provides access to configuration throughout the app