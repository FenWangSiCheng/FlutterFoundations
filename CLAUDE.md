# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

### Flutter Environment
This project uses FVM (Flutter Version Management) with Flutter 3.35.4. Always prefix Flutter commands with `fvm`:

- `fvm flutter pub get` - Install dependencies
- `fvm flutter pub deps` - Show dependency tree
- `fvm flutter clean && fvm flutter pub get` - Clean and reinstall dependencies

### Code Generation
The project uses build_runner for code generation (injectable, freezed, json_serializable, mockito):
- `fvm flutter packages pub run build_runner build` - Generate all code (DI, models, mocks)
- `fvm flutter packages pub run build_runner build --delete-conflicting-outputs` - Force regenerate

**Important**: Generated files (*.g.dart, *.freezed.dart, *.mocks.dart, *.config.dart) are NOT committed to Git. After cloning the repository, you MUST run code generation before building or running the app.

### Running the App
Multi-flavor setup using dart-define-from-file:
- `fvm flutter run --flavor dev --dart-define-from-file=dart_defines/dev.json` - Development
- `fvm flutter run --flavor stg --dart-define-from-file=dart_defines/stg.json` - Staging
- `fvm flutter run --flavor prod --dart-define-from-file=dart_defines/prod.json` - Production

### Building
- `fvm flutter build apk --flavor dev --dart-define-from-file=dart_defines/dev.json` - Development APK
- `fvm flutter build apk --flavor stg --dart-define-from-file=dart_defines/stg.json` - Staging APK
- `fvm flutter build apk --flavor prod --dart-define-from-file=dart_defines/prod.json` - Production APK
- `fvm flutter build ios --flavor prod --dart-define-from-file=dart_defines/prod.json` - Production iOS build

### Analysis and Testing
- `fvm flutter analyze` - Static analysis (required before commits)
- `fvm flutter test` - Run all unit tests
- `fvm flutter test test/specific_test.dart` - Run a single test file
- `fvm flutter test --coverage` - Run tests with coverage report
- `fvm flutter test test/features/user/` - Run tests for a specific feature
- `dart format .` - Format code

## Architecture

### Clean Architecture with Feature-First Structure
The codebase follows Clean Architecture principles organized by features:

```
lib/
├── features/                    # Feature modules (feature-first organization)
│   └── user/                    # Example: User feature
│       ├── domain/              # Business logic layer
│       │   ├── entities/        # Core business objects (User)
│       │   ├── repositories/    # Abstract repository interfaces
│       │   └── usecase/         # Business use cases
│       ├── data/                # Data layer
│       │   ├── datasource/      # Remote/local data sources
│       │   ├── models/          # Data transfer objects with toEntity() methods
│       │   └── repositories/    # Repository implementations
│       └── presentation/        # UI layer
│           └── pages/           # Feature-specific pages
└── core/                        # Shared/cross-cutting concerns
    ├── config/                  # App configuration (flavors, environment)
    ├── network/                 # HTTP client, interceptors, error handling
    │   ├── dio_client.dart      # Dio HTTP client setup with proxy support
    │   ├── interceptors/        # Auth and other interceptors
    │   ├── error/               # Error handling utilities
    │   └── mock/                # Mock API setup for development
    ├── injection/               # Dependency injection configuration
    ├── widgets/                 # Shared widgets
    └── constants/               # App-wide constants
```

### Dependency Injection
Uses `get_it` with `injectable` for dependency injection:
- `core/injection/injection.dart` - Main DI configuration with `configureDependencies()` function
- `core/injection/injection.config.dart` - Generated DI registration (auto-generated by build_runner)
- All services registered with `@Injectable()` annotations
- Repositories injected as interfaces using `@Injectable(as: Interface)`
- DioClient registered as `@preResolve` with `@lazySingleton` scope for async initialization

### Multi-Flavor Configuration
- `core/config/app_config.dart` - Contains Flavor enum and all configuration logic
- `dart_defines/` - JSON configuration files for each flavor:
  - `dev.json` - Development environment (flavor: "dev")
  - `stg.json` - Staging environment (flavor: "stg")
  - `prod.json` - Production environment (flavor: "prod")
- `AppConfig.fromEnvironment()` - Factory constructor that reads flavor from dart-define
- `AppConfig.currentFlavor` - Current flavor accessor
- `AppConfig.isProduction` - Production environment check
- `AppConfig.flavorTitle` - Human-readable flavor title for UI
- `AppConfig.mockApiDataSource` - Boolean flag to enable mock API responses
- `AppConfig.isNeedProxy` - Boolean flag to enable proxy configuration
- All dart-define fields use snake_case naming: `app_name`, `base_url`, `mock_api_data_source`, `is_need_proxy`
- Supports both full names (develop/staging/production) and short forms (dev/stg/prod)

### HTTP Client Setup
Located in `core/network/dio_client.dart`:
- Dio HTTP client with environment-specific base URLs from AppConfig
- Mock API adapter using `http_mock_adapter` when `mockApiDataSource` is true
- System proxy detection and configuration via `native_flutter_proxy`
- Auth interceptor for request authentication (`core/network/interceptors/auth_interceptor.dart`)
- Debug logging in development mode using Dio's LogInterceptor
- Proxy bypass for non-production environments
- Certificate validation handling for staging/dev environments

### Mock API Setup
Located in `core/network/mock/`:
- `mock_setup.dart` - Configures DioAdapter with mock responses
- `mock_responses.dart` - Defines mock response data
- Activated when `AppConfig.mockApiDataSource` is true (enabled in dev flavor)
- Useful for development without backend dependencies

### Key Dependencies
- `dio` - HTTP client
- `flutter_bloc` - State management
- `get_it` + `injectable` - Dependency injection
- `shared_preferences` - Local storage
- `flutter_inappwebview` - WebView integration
- `freezed` + `freezed_annotation` - Immutable data classes with code generation
- `json_serializable` + `json_annotation` - JSON serialization/deserialization
- `mockito` - Mocking for unit tests
- `build_runner` - Code generation orchestrator
- `http_mock_adapter` - Mock HTTP responses for development
- `native_flutter_proxy` - System proxy detection

### State Management with BLoC
The project uses `flutter_bloc` for state management following the BLoC pattern:
- **Events** (`*_event.dart`) - User actions or system events that trigger state changes
- **States** (`*_state.dart`) - Represent different UI states (Initial, Loading, Loaded, Error)
- **BLoC** (`*_bloc.dart`) - Business logic that transforms events into states
- All BLoCs are registered with dependency injection using `@injectable`
- BLoCs receive dependencies (use cases) via constructor injection
- Use `BlocProvider` to provide BLoCs to widget trees
- Use `BlocBuilder` to rebuild UI based on state changes

### Testing Strategy
Comprehensive testing is expected across all layers:

**Unit Tests:**
- **Domain Layer**: Test entities and use cases in isolation
- **Data Layer**: Test models, data sources, and repository implementations with mocks
- **Presentation Layer**: Test BLoCs using `bloc_test` package

**Widget Tests:**
- Test presentation layer pages and widgets using `flutter_test`
- Mock BLoCs and verify UI rendering for different states
- Test user interactions (button taps, form inputs)

**Test File Organization:**
- Mirror the `lib/` structure in `test/` directory
- Use `@GenerateMocks` from `mockito` to generate mocks
- Run `build_runner` after adding new mock annotations
- Aim for high test coverage (target: >80%)

**Example Test Pattern:**
```dart
@GenerateMocks([Repository])
void main() {
  late MockRepository mockRepository;
  late UseCase useCase;

  setUp(() {
    mockRepository = MockRepository();
    useCase = UseCase(mockRepository);
  });

  test('description', () async {
    // Arrange
    when(mockRepository.method()).thenAnswer((_) async => result);
    // Act
    final result = await useCase();
    // Assert
    verify(mockRepository.method()).called(1);
    expect(result, expected);
  });
}
```

### Error Handling
Centralized error handling approach:
- `core/network/error/exception.dart` - Custom exception classes (ApiException, CacheException, etc.)
- `core/network/error/dio_error_handler.dart` - Converts DioException to custom exceptions
- Data sources catch and throw custom exceptions
- Repositories propagate exceptions to use cases
- BLoCs catch exceptions and emit error states
- UI layer displays user-friendly error messages

## Important Notes

- Always run `fvm flutter analyze` before committing changes
- Generated files (*.g.dart, *.freezed.dart, *.mocks.dart) must be regenerated after cloning or modifying annotations
- The project follows feature-first organization - keep feature code within its module
- Respect Clean Architecture layer boundaries: domain → data → presentation
  - Domain layer has NO dependencies on other layers
  - Data layer depends only on domain layer
  - Presentation layer depends on domain and data layers
- Use the existing DI container (`getIt`) rather than creating manual dependencies
- Follow the established naming conventions: UpperCamelCase for types, lowerCamelCase for members
- Flavor-specific resources are organized in platform folders (android/ios have flavor subdirectories)
- When adding new features, follow the existing feature module structure under `lib/features/`
- Data models should always have a `toEntity()` method to convert to domain entities
- The global `appConfig` variable in `main.dart` provides access to configuration throughout the app
- Use `Equatable` for value equality in events, states, and entities
- BLoCs should only contain presentation logic; business logic belongs in use cases